## 27-递归树：如何借助树来求解递归算法的时间复杂度？


我们都知道，递归代码的时间复杂度分析起来很麻烦。我们在第 12 节《排序（下）》那里讲过，如何利用递推公式，求解归并排序、快速排序的时间复杂度，但是，有些情况，比如快排的平均时间复杂度的分析，用递推公式的话，会涉及非常复杂的数学推导。

除了用递推公式这种比较复杂的分析方法，有没有更简单的方法呢？今天，我们就来学习另外一种方法，借助递归树来分析递归算法的时间复杂度。

递归树与时间复杂度分析

我们前面讲过，递归的思想就是，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。

如果我们把这个一层一层的分解过程画成图，它其实就是一棵树。我们给这棵树起一个名字，叫作递归树。我这里画了一棵斐波那契数列的递归树，你可以看看。节点里的数字表示数据的规模，一个节点的求解可以分解为左右子节点两个问题的求解。



通过这个例子，你对递归树的样子应该有个感性的认识了，看起来并不复杂。现在，我们就来看，如何用递归树来求解时间复杂度。

归并排序算法你还记得吧？它的递归实现代码非常简洁。现在我们就借助归并排序来看看，如何用递归树，来分析递归代码的时间复杂度。

归并排序的原理我就不详细介绍了，如果你忘记了，可以回看一下第 12 节的内容。归并排序每次会将数据规模一分为二。我们把归并排序画成递归树，就是下面这个样子：



因为每次分解都是一分为二，所以代价很低，我们把时间上的消耗记作常量 1
1
。归并算法中比较耗时的是归并操作，也就是把两个子数组合并为大数组。从图中我们可以看出，每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关。我们把每一层归并操作消耗的时间记作 n
n
。

现在，我们只需要知道这棵树的高度 h
h
，用高度 h
h
乘以每一层的时间消耗 n
n
，就可以得到总的时间复杂度 O(n∗h)
O
(
n
∗
h
)
。

从归并排序的原理和递归树，可以看出来，归并排序递归树是一棵满二叉树。我们前两节中讲到，满二叉树的高度大约是 log2n
log
2
⁡
n
，所以，归并排序递归实现的时间复杂度就是 O(nlogn)
O
(
n
log
⁡
n
)
。我这里的时间复杂度都是估算的，对树的高度的计算也没有那么精确，但是这并不影响复杂度的计算结果。

利用递归树的时间复杂度分析方法并不难理解，关键还是在实战，所以，接下来我会通过三个实际的递归算法，带你实战一下递归的复杂度分析。学完这节课之后，你应该能真正掌握递归代码的复杂度分析。

实战一：分析快速排序的时间复杂度

在用递归树推导之前，我们先来回忆一下用递推公式的分析方法。你可以回想一下，当时，我们为什么说用递推公式来求解平均时间复杂度非常复杂？

快速排序在最好情况下，每次分区都能一分为二，这个时候用递推公式 T(n)=2T(n2)+n
T
(
n
)
=
2
T
(
n
2
)
+
n
，很容易就能推导出时间复杂度是 O(nlogn)
O
(
n
log
⁡
n
)
。但是，我们并不可能每次分区都这么幸运，正好一分为二。

我们假设平均情况下，每次分区之后，两个分区的大小比例为 1:k
1
:
k
。当 k=9
k
=
9
 时，如果用递推公式的方法来求解时间复杂度的话，递推公式就写成 T(n)=T(n10)+T(9n10)+n
T
(
n
)
=
T
(
n
10
)
+
T
(
9
n
10
)
+
n
。

这个公式可以推导出时间复杂度，但是推导过程非常复杂。那我们来看看，用递归树来分析快速排序的平均情况时间复杂度，是不是比较简单呢？

我们还是取 k
k
 等于 9
9
，也就是说，每次分区都很不平均，一个分区是另一个分区的 9
9
 倍。如果我们把递归分解的过程画成递归树，就是下面这个样子：



快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是 n
n
。我们现在只要求出递归树的高度 h
h
，这个快排过程遍历的数据个数就是 h∗n
h
∗
n
，也就是说，时间复杂度就是 O(h∗n)
O
(
h
∗
n
)
。

因为每次分区并不是均匀地一分为二，所以递归树并不是满二叉树。这样一个递归树的高度是多少呢？

我们知道，快速排序结束的条件就是待排序的小区间，大小为 1
1
，也就是说叶子节点里的数据规模是 1
1
。从根节点 n
n
 到叶子节点 1
1
，递归树中最短的一个路径每次都乘以 110
1
10
，最长的一个路径每次都乘以 910
9
10
。通过计算，我们可以得到，从根节点到叶子节点的最短路径是 log10n
log
10
⁡
n
，最长的路径是 log109n
log
10
9
⁡
n
。



所以，遍历数据的个数总和就介于 nlog10n
n
log
10
⁡
n
 和 nlog109n
n
log
10
9
⁡
n
 之间。根据复杂度的大 O 表示法，对数复杂度的底数不管是多少，我们统一写成 logn
log
⁡
n
，所以，当分区大小比例是 1:9
1
:
9
 时，快速排序的时间复杂度仍然是 O(nlogn)
O
(
n
log
⁡
n
)
。

刚刚我们假设 k=9
k
=
9
，那如果 k=99
k
=
99
，也就是说，每次分区极其不平均，两个区间大小是 1:99
1
:
99
，这个时候的时间复杂度是多少呢？

我们可以类比上面 k=9
k
=
9
 的分析过程。当 k=99
k
=
99
 的时候，树的最短路径就是 log100n
log
100
⁡
n
，最长路径是 log10099n
log
100
99
⁡
n
，所以总遍历数据个数介于 nlog100n
n
log
100
⁡
n
 和 nlog10099n
n
log
100
99
⁡
n
 之间。尽管底数变了，但是时间复杂度也仍然是 O(nlogn)
O
(
n
log
⁡
n
)
。

也就是说，对于 k
k
 等于 9
9
，99
99
，甚至是 999
999
，9999
9999
……，只要 k
k
 的值不随 n
n
 变化，是一个事先确定的常量，那快排的时间复杂度就是 O(nlogn)
O
(
n
log
⁡
n
)
。所以，从概率论的角度来说，快排的平均时间复杂度就是 O(nlogn)
O
(
n
log
⁡
n
)
。

实战二：分析斐波那契数列的时间复杂度

在递归那一节中，我们举了一个跨台阶的例子，你还记得吗？那个例子实际上就是一个斐波那契数列。为了方便你回忆，我把它的代码实现贴在这里。

int f(int n) {
  if (n == 1) return 1;
  if (n == 2) return 2;
  return f(n-1) + f(n-2);
}
复制代码
这样一段代码的时间复杂度是多少呢？你可以先试着分析一下，然后再来看，我是怎么利用递归树来分析的。

我们先把上面的递归代码画成递归树，就是下面这个样子：



