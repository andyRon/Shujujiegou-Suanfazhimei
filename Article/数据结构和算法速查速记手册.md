# 学习路线

![学习路线](images/3eb147a56e5b1452692fbbd4498075b7.png)

![](images/84645c7329fe66d311e4ae4c4920618f.jpg)

![](images/d37136dd9b2341abf5a41167d3e50c79.jpg)

![](images/9cb3a84ee91d8f8c1849e1bd7bc4a8fe.jpg)

![](images/52788574ceabff1adbdebfe69d3debce.jpg)

# 数据结构和算法速查速记手册


来自公众号：`小争哥`。

## 一、数组、链表、栈、队列

### 01 数组

|              |                                                              |
| ------------ | ------------------------------------------------------------ |
| 概念与特性   | 1. 数组是线性表，用一组连续的内存空间存储一组具有相同类型的数据; <br/>2. 最大的特性是支持按照下标O(1)时间复杂度内快速访问数组元素;<br/>3. 一维数组寻址公式:`a[i]_addr = base_addr + i * data_type_size;` |
| 操作与复杂度 | 1. 随机访问时间复杂度是O(1);<br/>2. 在数组中间任意位置插入数据的时间复杂度是O(n);<br/>3. 删除数组中任意位置数据的时间复杂度是O(n); |
| 应用场景     | 数组是其他数据结构和算法的实现基础，比如栈、队列、堆、二分查找等 |
| 其他知识点   | 1. 数组需要连续的内存空间，对内存的要求较高;<br/>2. 数组中的数据连续存储，对CPU缓存友好;<br/>3. 大部分编程语言中，数组下标都是从0开始编号;<br/>4. 大部分编程语言中，都提供了容器类型以支持动态数组(动态扩容); <br/>5. 编程语言中的数组类型并不等同于数据结构中讲的数组; |
| 掌握程度     | 能够自己动手实现一个动态数组类。                             |

### 02 链表

| Shujuejiegou |                                                              |
| ------------ | ------------------------------------------------------------ |
| 概念与特性   | 1. 链表是线性表，不需要连续的内存空间来存储元素，通过指针将串联每 个链表中的结点;<br/>2. 常用的链表结构有:单链表、双向链表、循环链表，其中双向链表因为 支持在O(1)时间复杂度内找到前驱结点，在实际开发中最常用; |
| 操作与复杂度 | 1. 跟数组对比，查找第i个元素的时间复杂度是O(n);<br/>2. 在已知前驱结点的情况下，单链表中插入数据的时间复杂度是O(1); <br/>3. 在已知前驱结点的情况下，单链表中删除数据的时间复杂度是O(1);<br/><br/>**注意**:上面的插入、删除操作，都是针对已知前驱结点的情况，如果未知 前驱结点，在单链表中插入、删除数据时间复杂度是O(n)，而在双向链表 中插入、删除数据的时间复杂度仍然是O(1)。这也是双向链表比单链表更 常用的主要原因。 |
| 应用场景     | 链表是其他数据结构和算法的实现基础，比如跳表、散列表等;      |
| 其他知识点   | 1. 链表中的数据不连续存储，对CPU缓存不友好;<br/>2. 在实际的编程中，可定义有头链表，也可以定义无头链表;有头链表指的是链表中的头结点不存储数据; |
| 掌握程度     | 1. 熟练实现单链表、双向链表、循环链表的定义和操作;<br/>2. 熟练实现经典的链表题目，比如反转链表、链表求中间结点、合并有序 链表、删除链表倒数第K个结点等; |

### 03 栈

|              |                                                              |
| ------------ | ------------------------------------------------------------ |
| 概念与特性   | 1. 栈是一种操作受限的线性表，只能在一端插入删除数据;<br/>2. 栈的最大特性是先进后出; |
| 操作与复杂度 | 1. 入栈操作，在栈顶放入数据，时间复杂度是O(1);<br/> 2. 出栈操作，从栈顶取出数据，时间复杂度是O(1); |
| 应用场景     | 1. 函数调用栈;<br/>2. 编译器利用栈来实现表达式求值;<br/>3. 浏览器中的前进后退功能的实现也会用到栈; |
| 其他知识点   | 1. 栈既可以用数组来实现，也可以用链表来实现;<br/>2. 基于数组实现的支持动态扩容的栈的插入操作的均摊时间复杂度是<br/>O(1); |
| 掌握程度     | 1. 熟练利用数组实现一个栈;<br/>2. 熟练利用链表实现一个栈;<br/>3. 掌握基于数组实现的支持动态扩容的栈的插入操作的时间复杂度分析;<br/> 4. 用栈检查括号是否匹配，比如:`{[()]()[{}]}`或`[{()}([])]`等都为合法格式，而`{[}()]`或`[({)]`为不合法的格式; |

###  04 队列

|              |                                                              |
| ------------ | ------------------------------------------------------------ |
| 概念与特性   | 1. 队列是一种操作受限的线性表，只能在两端插入、删除数据;<br/>2. 队列的最大特性是先进先出; |
| 操作与复杂度 | 1. 入队操作，在队尾插入数据，时间复杂度是O(1); <br/>2. 出队操作，从队头取出数据，时间复杂度是O(1); |
| 应用场景     | 队列常用在有限资源池中，用于排队请求，比如数据库连接池等;    |
| 其他知识点   | 1. 队列既可以用数组来实现，也可以用链表来实现; <br/>2. 最⻓使用的队列是基于数组实现的循环队列; |
| 掌握程度     | 熟练实现一个循环队列，重点是掌握队列的判空和判满条件;        |

## 二、递归、排序、二分查找

### 05 递归

| Shujujiegou |                                                              |
| ----------- | ------------------------------------------------------------ |
| 概念与特性  | 函数调用函数自身的编程方式叫做递归，调用为”递“，返回为”归“。 |
| 三个条件    | 1. 一个问题的解可以分解为多个子问题的解;<br/>2. 分解之后的子森缇，除了数据规模不同，求解思路跟原问题相同; <br/>3. 存在递归终止条件; |
| 编程技巧    | 1. 寻找将大问题分解为小问题求解的规律;<br/>2. 找出递推公式和终止条件，将其直接翻译成代码; <br/>3. 切记不要人肉一层一层的递归;<br/><br/>换句话说，也就是:如果一个问题A可以分解为若干子问题B、C、D，我 们可以假设子问题B、C、D已经解决，在此基础上思考如何解决问题A。 我们只需要思考问题A与子问题B、C、D两层之间的关系即可，不需要一 层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。 |
| 应用场景    | 递归是一种应用非常广泛编程技巧，很多数据结构和算法的编码实现都要 用到递归，比如快排、归并排序、DFS、二叉树遍历、回溯等; |
| 其他知识点  | 1. 避免堆栈溢出(限制调用层次;递归改为迭代;尾递归优化); <br/>2. 避免重复计算(利用备忘录); |
| 掌握程度    | 1. 熟练编写斐波那契数列、全排列、八皇后、快速排序;归并排序、 DFS、二叉树遍历、链表反转递归实现等;<br/>2. 掌握递归算法的时间、空间复杂度分析;其中时间复杂度通过递推公式 或者递归树来分析;空间复杂度跟递归函数调用栈深度成正比; |



### 06 排序

| ================  |                                                              |
| ----------------- | ------------------------------------------------------------ |
| 概念与特性        | 1. 稳定性:如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变; <br/>2. 原地:不额外申请非常量级的空间来临时存储排序数据;原地排序算法并不一定空间复杂度是O(1)，空间复杂度是O(1)的排序算法一定是原地排序算法，比如快速排序是原地排序算法，但因为用到递归，函数调用栈会消耗非常量级的空间，所以，空间复杂度并非O(1)，是O(logn)。 |
| O(n^2) 冒泡排序   | 冒泡排序是**稳定原地排序**算法。<br/><br/>整个冒泡排序过程包含多遍冒泡操作。每次冒泡操作都会遍历整个数组，依次对相邻的元素进行比较，看是否满足大小关系要求，如果不满足，就将它们互换位置。一次冒泡操作会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的 排序工作。 |
| O(n^2) 插入排序   | 插入排序是稳定原地排序算法。<br/><br/>首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组中的第一个元素。插入算法的核心思想是**取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序**。重复这个过程，直到未排序区间中元素为空，算法结束。 |
| O(n^2) 选择排序   | 选择排序算法是非稳定原地排序算法。<br/><br/>其实现思路有点类似插入排序，也分已排序区间和未排序区间。 但不同点在于，选择排序算法每次会从未排序区间中，找到最小的元素，将其放到已排序区间的末尾。 |
| O(nlogn) 快速排序 | 非稳定原地排序算法。<br/>如果要排序数组中下标从p到r之间的一组数据，我们选择p到r之间的任意一个数据作为pivot(分区点)，然后，遍历p到r之间的数据，将小于pivot的放到左边，将大于pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，p到r之间的数据就被分成 了三个部分。假设pivot 现在所在位置的下标是q，那p到q-1之 间数据都小于pivot ，中间是pivot ，q+1到r之间的数据都大于 pivot 。根据分治、递归的处理思想，我们递归排序下标从p到 q-1之间的数据和下标从q+1到r之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。<br/><br/>递推公式:<br/> quickSort(p...r)=quickSort(p...q-1) & quickSort(q+1...r) |
| O(n) 归并排序     | 稳定非原地排序算法。<br/>如果要排序一个数组，我们先把数组从中间分成前后两部分，然 后，对前后两部分分别排序，再将排好序的两部分合并在一起， 这样整个数组就都有序了。<br/>递推公式:<br/> mergeSort(p...r)=merge(mergeSort(p...q), mergeSort(q+1... r)) |
| O(n) 桶排序       |                                                              |
| O(n) 计数排序     |                                                              |
| O(n) 基数排序     |                                                              |
| 应用场景          | 工程中的排序函数一般使用O(nlogn)的快排、归并或者堆排序作为主排序算法，当数据规模较小时，转而选择使用更加简单的插入排序。 |
| 其他知识点        | 为了避免快速排序时间复杂度退化为极端情况O(n^2)，我们使用更加高级的分区点选择方式，比如三数取中法、随机法等。 |
| 掌握程度          | 1. 熟练掌握冒泡、插入、选择、快速、归并排序的原理、代码实现; <br/>2. 熟练掌握快速、归并排序的时间和空间复杂度分析;<br/>3. 掌握桶排序、计数排序、基数排序的原理; |

### 

### 07 二分查找

|              |                                                              |
| ------------ | ------------------------------------------------------------ |
| 概念与特性   | 二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每 次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0。 |
| 操作与复杂度 | O(logn)                                                      |
| 二分查找变体 | 变体一:查找第一个值等于给定值的元素<br/>变体二:查找最后一个值等于给定值的元素<br/>变体三:查找第一个大于等于给定值的元素<br/>变体四:查找最后一个小于等于给定值的元素 |
| 掌握程度     | 熟练掌握二分查找、二分查找变体的代码实现。                   |
|              |                                                              |

##三、散列表、位图、哈希算法 

### 08 散列表

| ===========  |                                                              |
| ------------ | ------------------------------------------------------------ |
| 概念与特性   | 散列表的英文翻译是“Hash Table”，所以，我们平时也叫它“哈希表”或者“Hash表”。实际上，散列表是数组的一种扩展，由数组演化而来，底层依赖数组支持按下标随机访问的特性，所以，可以说，如果没有数组，就没有散列表。 |
| 操作与复杂度 | 理论上讲，散列表插入、删除、查找数据的时间复杂度是O(1)。更加准确一点，性能跟装载因子成相关性。 |
| 散列冲突解决 | 1. 开放寻址法，如果一旦出现散列冲突，就通过重新探测新位置的方法来 解决冲突。<br/>2.链表法，它是一种更加常用的解决散列冲突办法，相比开放寻址法，它要简单得多。在散列表中，每个“桶(bucket )”或者“槽(slot )”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。 |
| 应用场景     | 1. 支持快速插入、删除、查找数据的动态集合;<br/>2. 编程语言中常用的Map结构，比如Java中的HashMap;<br>3. 跟有序链表组合使用，实现LRU缓存淘汰算法; |
| 其他知识点   | 1. 支持动态扩容的散列表，为了避免一次性扩容导致的耗时过多，我们可以将扩容操作穿插在插入操作的过程中，分批完成。<br>2. 为了提高散列表的性能，对基于链表法解决散列冲突的链表，当链表⻓度大于等于8时，将链表转化成红黑树。当红黑树中节点个数小于等于6时，又会将红黑树转化成链表。 |
| 掌握程度     | 1. 掌握散列表的原理，冲突解决方案; <br>2. 掌握LRU缓存淘汰算法的实现原理; |

### 09 位图

| ============ |                                                              |
| ------------ | ------------------------------------------------------------ |
| 概念与特性   | 1. 位图是一种特殊的散列表，集合中的元素跟位图中的某一位一一对应。 <br>2. 布隆过滤器是对位图的优化，为得是节省内存空间，比起位图来说，它使用多个散列函数对应多个位来确定一个元素。 |
| 操作与复杂度 | 1. 位图支持插入、删除、查找操作，时间复杂度是O(1)，空间复杂度跟数 据范围大小有关。<br>2. 布隆过滤器支持插入、查找，一般不支持删除，时间复杂度是O(1)，空 间消耗较位图要小。 |
| 应用场景     | 1. 搜索引擎爬虫URL去重; <br>2. 垃圾邮件判别;                 |
| 其他知识点   | 布隆过滤器存在误判的情况，不过，只有在判断存在的情况下，才有可能 发生误判，也就是说，判定存在有可能并不存在。如果某个数据经过布隆 过滤器判断不存在，那说明这个数字真的不存在，这种情况是不会有误判 的。 |
| 掌握程度     | 1. 掌握位图的代码实现;<br/>2. 掌握布隆过滤器的原理和应用;    |
|              |                                                              |

### 10 哈希算法

| ==========   |                                                              |
| ------------ | ------------------------------------------------------------ |
| 概念与特性   | 哈希算法的定义和原理非常简单，一句话就能概括:将任意⻓度的二进制 值串映射为固定⻓度的二进制值串，这个映射的规则就叫“哈希算法”。原 始数据映射之后得到的二进制值串就叫“哈希值”。一般来讲，哈希算法还 要满足下面几点:<br>- 从哈希值不能反向推导出原始数据(因此哈希算法也叫单向哈希算 法);<br>- 对输入数据非常敏感，哪怕原始数据只修改了一个二进制位，最后得到 的哈希值也大不相同;<br>- 散列冲突的概率要很小，不同原始数据对应相同哈希值的概率非常小;<br>- 哈希算法的执行效率要高，对较⻓的文本，也能快速计算出哈希值 |
| 操作与复杂度 |                                                              |
| 应用场景     |                                                              |
| 其他知识点   |                                                              |
| 掌握程度     |                                                              |
|              |                                                              |

## 四、二叉树、BST 、BBST 、递归树、B+树

### 11 二叉树

|              |      |
| ------------ | ---- |
| 概念与特性   |      |
| 操作与复杂度 |      |
| 应用场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
|              |      |



### 12 二叉查找树

|              |      |
| ------------ | ---- |
| 概念与特性   |      |
| 操作与复杂度 |      |
| 应用场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
|              |      |



### 13 平衡二叉查找树

|              |      |
| ------------ | ---- |
| 概念与特性   |      |
| 操作与复杂度 |      |
| 应用场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
|              |      |



### 14 递归树

|              |      |
| ------------ | ---- |
| 概念与特性   |      |
| 操作与复杂度 |      |
| 应用场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
|              |      |

### 15 B+树

|              |      |
| ------------ | ---- |
| 概念与特性   |      |
| 操作与复杂度 |      |
| 应用场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
|              |      |

## 五、堆、堆排序

### 16 堆

|              |      |
| ------------ | ---- |
| 概念与特性   |      |
| 操作与复杂度 |      |
| 应用场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
|              |      |

### 17 堆排序

|              |      |
| ------------ | ---- |
| 概念与特性   |      |
| 操作与复杂度 |      |
| 应用场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
|              |      |

## 六、跳表、并查集、线段树、树状数组

### 18 跳表

|              |      |
| ------------ | ---- |
| 概念与特性   |      |
| 操作与复杂度 |      |
| 应用场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
|              |      |

### 19 并查集

|              |      |
| ------------ | ---- |
| 概念与特性   |      |
| 操作与复杂度 |      |
| 应用场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
|              |      |

### 20 线段树

|              |      |
| ------------ | ---- |
| 概念与特性   |      |
| 操作与复杂度 |      |
| 应用场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
|              |      |

### 21 树状数组

|              |      |
| ------------ | ---- |
| 概念与特性   |      |
| 操作与复杂度 |      |
| 应用场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
|              |      |

## 七、字符串匹配算法

### 22 单模式字符串匹配算法

|              |      |
| ------------ | ---- |
| 概念与特性   |      |
| 操作与复杂度 |      |
| 应用场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
|              |      |

### 23 多模式字符串匹配算法

|              |      |
| ------------ | ---- |
| 概念与特性   |      |
| 操作与复杂度 |      |
| 应用场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
|              |      |

## 八、图和图算法

### 24 图的表示

|              |      |
| ------------ | ---- |
| 概念与特性   |      |
| 操作与复杂度 |      |
| 应用场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
|              |      |

### 25 图的算法

|              |      |
| ------------ | ---- |
| 概念与特性   |      |
| 操作与复杂度 |      |
| 应用场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
|              |      |

## 九、贪心、分治、回溯、动态规划

### 26 算法思想

| ============ |                                                              |
| ------------ | ------------------------------------------------------------ |
| 贪心         | 实际上，贪心算法适用的场景比较有限。这种算法思想更多的是指导设计基础算法。比如最小生成树算法、单源最短路径算法，这些算法都用到了贪心算法。从我个人的学习经验来讲，不要刻意去记忆贪心算法的原理， 多练习才是最有效的学习方法。<br><br>对于贪心算法，最难的一块是如何将要解决的问题抽象成贪心算法模型， 只要这一步搞定之后，贪心算法的编码一般都很简单。虽然很多时候贪心算法解决问题的正确性看起来显而易⻅，但要严谨地证明算法能够得到最优解，并不是件容易的事。所以，很多时候，我们只需要多举几个例子， 验证一下贪心算法的解决方案能得到最优解就可以了。 |
| 分治         | 分治算法(divide and conquer)的核心思想其实就是四个字:分而治之 ，详细点讲，就是将原问题划分成n个规模更小并且结构与原问题相似的子 问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。<br><br>分治看起来有点像递归。分治算法是一种处理问题的思想，递归是一种编 程技巧。实际上，分治算法一般都比较适合用递归来实现。分治算法的递 归实现中，每一层递归都会涉及下面这样三个操作: <br>分解:将原问题分解成一系列子问题; <br>解决:递归地求解各个子问题，若子问题足够小，则直接求解; <br>合并:将子问题的结果合并成原问题。 |
| 回溯         | 回溯算法思想非常简单，大部分情况下，都是用来解决广义的搜索问题， 也就是，从一组可能的解中，选出一个满足要求的解。回溯算法非常适合 用递归来实现，在实现的过程中，剪枝操作是提高回溯效率的一种技巧。 利用剪枝，可以提前终止不能满足要求的情况，从而提高搜索效率。 |
| 动态规划     | 什么样的问题适合用动态规划解决?这些问题可以总结概括为“一个模型三 个特征”。其中，“一个模型”指的是问题可以抽象成分阶段决策最优解模 型。“三个特征”指的是最优子结构、无后效性和重复子问题。<br><br>动态规划有两种解题思路，分别是状态转移表法和状态转移方程法。其 中，状态转移表法解题思路大致可以概括为:回溯算法实现-定义状态-画 递归树-找重复子问题-画状态转移表-根据递推关系填表-将填表过程翻译 成代码。状态转移方程法的大致思路可以概括为:找最优子结构-写状态 转移方程-将状态转移方程翻译成代码。 |
| 掌握程度     | 1. 熟练掌握贪心算法经典问题:分糖果、最短服务时间、区间覆盖; <br>2. 熟练掌握分治算法经典问题:快排、归并排序;  <br/>3. 熟练掌握回溯算法经典问题:八皇后、全排列、0-1背包、正则表达式;  <br/>4. 熟练掌握动态规划经典问题:背包问题、杨辉三⻆、走格子、硬币找 |
|              |                                                              |

